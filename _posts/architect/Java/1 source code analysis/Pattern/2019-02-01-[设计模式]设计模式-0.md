---
layout: post
title:  "[常用设计模式]设计模式"
date:   2019-2-1 20:00:00 +0800
tags: 常用设计模式
color: rgb(26,62,110)
cover: 'https://github.com/javasunCN/zhangzhBolg/blob/master/assets/img/spring/spring.jpg?raw=true'
subtitle: '设计模式'
---

![Java Logo]({{ site.url }}{{site.baseurl}}/assets/img/cxy.jpg)
{: .image-pull-right}

------------------------


# **设计模式入门**
{% highlight text %} 
    概念:设计模式是面对同类型软件设计问题，能被反复使用、经过分类的代码设计经验总结
        模式不是代码，而是某类问题的通用设计解决方案
    发起者: 《设计模式》Erich Gamma / Richard Helm / Ralph Johnson / John Vlissides
    面向对象设计模式编程思想:
        通过封装、继承、多态把程序耦合度降低
        业务封装:让业务逻辑与界面逻辑分开
        
    学习设计模式最好方式：
        在自己的做的工程中尽量思考使用
        
    设计原则：
        1、开闭原则[（Open Close Principle,简称OCP）]
            - 核心思想:软件体应该是对于扩展开放的，但是对于修改封闭的
                尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化
            - 理解:对于软件需求的多样，在设计时尽量的适应变化，提高项目的稳定性和灵活性
            - 应用: 当需求有改动，要修改代码了，此时您要做的是，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。
                当然，如果能够确保对整体架构不会产生任何影响，那么也没必要搞得那么复杂了，直接改这个类吧。
            
        2、里氏代换原则[(Liskov Substitution Principle, 简称LSP)]
            - 核心思想:程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换
            - 理解: 父类出现的地方子类都能出现
                - 增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行
            - 注意: 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，
                则建议断开父子继承关系 采用依赖、聚合、组合等关系代替继承
            - 应用: 在继承类时，务必重写（Override）父类中所有的方法，尤其需要注意父类的 protected 方法（它们往往是让您重写的），
                子类尽量不要暴露自己的 public 方法供外界调用。
                
        3、依赖倒置原则[（Dependence Inversion Principle,简称DIP）]
            - 核心思想: 认为一个方法应该遵从“依赖于抽象而不是一个实例”
                - 高层模块不应该依赖底层模块，二者都该依赖其抽象；(高层模块就是调用端，低层模块就是具体实现类)
                - 抽象不应该依赖细节；细节应该依赖抽象；(抽象就是指接口或抽象类。细节就是实现类)
            - 理解: 依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合
                依赖注入是该原则的一种实现方式
            - 应用: 并不是说，所有的类都要有一个对应的接口，而是说，如果有接口，那就尽量使用接口来编程吧
            
        4、接口隔离原则[（Interface Segregation Principle,简称ISP）]
            - 核心思想: 多个特定客户端接口要好于一个宽泛用途的接口(类间的依赖关系应该建立在最小的接口上)
            - 理解: 为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用
            - 应用: 当需要对外暴露接口时，需要再三斟酌，如果真的没有必要对外提供的，就删了吧。一旦您提供了，
                就意味着，您将来要多做一件事情，何苦要给自己找事做呢
            
        5、单一职责原则[（Single Responsibility Principle - SRP）]
            - 核心思想: 有且仅有一个原因引起类的变更
            - 理解: 假如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作
            - 应用: 当我们做系统设计时，如果发现有一个类拥有了两种的职责，那就问自己一个问题：
                可以将这个类分成两个类吗？如果真的有必要，那就分吧。千万不要让一个类干的事情太多！
            
        6、最少知识原则[迪米特法则（Law of Demeter,简称LoD）]
            - 核心思想:类间解耦
            - 一个类对自己依赖的类知道的越少越好。软件编程的总的原则：低耦合，高内聚。
            - 应用: 在做系统设计时，不要让一个类依赖于太多的其他类，需尽量减小依赖关系，否则，您死都不知道自己怎么死的。
    
{% endhighlight %}

# **设计模式分类**
## **创建型模式**
#### **1 单例模式**
{% highlight text %} 
    解释: 某个类只能有一个实例，提供全局访问点
        
{% endhighlight %}

#### **2 抽象工厂模式**
{% highlight text %} 
    解释: 创建相关或依赖的对象家族，而无需明确指定具体类
        
{% endhighlight %}
#### **3 建造者模式**
{% highlight text %} 
    解释: 封装一个复杂对象的构建过程，并按步骤构建
        
{% endhighlight %}

#### **4 工厂模式**
{% highlight text %} 
    解释:
        简单工厂：根据传入的参数决定创建那种产品实例
        工厂方法：定义一个创建对象的接口，让子类决定实例化那个类
        
    
{% endhighlight %}

#### **5 原型模式**
{% highlight text %} 
    解释: 通过复用现有的实例来创建新的实例
        
{% endhighlight %}


## **结构型模式**
#### **6 适配器模式**
{% highlight text %} 
    解释: 将一个类的方法接口转换成客户希望的另外一个接口
        
{% endhighlight %}

#### **7 桥接模式**
{% highlight text %} 
    解释: 将抽象部分与它的实现部分分离，使他们可以独立的变化
        
{% endhighlight %}

#### **8 装饰模式**
{% highlight text %} 
    解释: 动态的给对象添加新的功能
        
{% endhighlight %}

#### **9 组合模式**
{% highlight text %} 
    解释: 将对象组合成树形结构，以表示"部分-整体"的层次结构
        
{% endhighlight %}

#### **10 外观模式**
{% highlight text %} 
    解释: 通过统一的方法来访问子系统的一部分接口
        
{% endhighlight %}

#### **11 享元模式**
{% highlight text %} 
    解释: 通过共享技术有效的支持大量细粒度的对象
        用于减少创建对象的数量，以减少内存占用和提高性能
        
{% endhighlight %}

#### **12 代理模式**
{% highlight text %} 
    解释: 为其他对象提供一个代理，以控制对这个对象的访问
        
{% endhighlight %}



## **行为型模式**
#### **13 模板方法模式**
{% highlight text %} 
    解释: 定义一个算法结构，而将一些步骤延迟到子类中实现
        
{% endhighlight %}

#### **14 命令模式**
{% highlight text %} 
    解释: 将命令请求封装成一个对象，使得可用不同的请求来进行参数化
        
{% endhighlight %}

#### **15 迭代器模式**
{% highlight text %} 
    解释: 一种遍历访问聚合对象中各个元素的方法，不暴露改对象的内部结构
        
{% endhighlight %}

#### **16 观察者模式**
{% highlight text %} 
    解释: 对象之间是一对多的依赖关系
        
{% endhighlight %}

#### **17 中介者模式**
{% highlight text %} 
    解释: 用一个中介对象来封装一系列的对象交互
        
{% endhighlight %}

#### **18 备忘录模式**
{% highlight text %} 
    解释: 在不破坏封装性的前提下，保存对象的内部状态
        
{% endhighlight %}

#### **19 解释器模式**
{% highlight text %} 
    解释: 给定一个语言，定义它的语法表示，并定义一个解释器
        
{% endhighlight %}

#### **20 状态模式**
{% highlight text %} 
    解释: 允许一个对象在其内部状态改变时改变行为
        
{% endhighlight %}

#### **21 策略模式**
{% highlight text %} 
    解释: 定义一系列算法，把它们封装起来，并使它们可以相互替换
        
{% endhighlight %}

#### **22 职责链模式(责任链模式)**
{% highlight text %} 
    解释: 请求发送者和接收者之间解耦，使得多个对象都有机会处理这个请求
        
{% endhighlight %}

#### **23 访问者模式**
{% highlight text %} 
    解释: 在不改变数据结构的前提下，增加作用于一组对象元素新的功能
        
{% endhighlight %}



# **合理使用设计模式**
{% highlight text %} 
    一、在系统中如何恰到好处的使用设计模式？
        1、完全了解面临的问题的本质；
        2、完全了解设计模式的概念、原理、优缺点等；
        3、了解使用设计模式能解决什么实际问题，如果不知道最好不要滥用；
        
{% endhighlight %}






