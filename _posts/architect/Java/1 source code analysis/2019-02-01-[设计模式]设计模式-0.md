---
layout: post
title:  "[常用设计模式]设计模式"
date:   2019-2-1 20:00:00 +0800
tags: 常用设计模式
color: rgb(26,62,110)
cover: 'https://github.com/javasunCN/zhangzhBolg/blob/master/assets/img/spring/spring.jpg?raw=true'
subtitle: '设计模式'
---

![Java Logo]({{ site.url }}{{site.baseurl}}/assets/img/cxy.jpg)
{: .image-pull-right}

------------------------


# **设计模式入门**
{% highlight text %} 
    概念:设计模式是面对同类型软件设计问题，能被反复使用、经过分类的代码设计经验总结
        模式不是代码，而是某类问题的通用设计解决方案
    发起者: 《设计模式》Erich Gamma / Richard Helm / Ralph Johnson / John Vlissides
    设计模式
        优点：
        用途：
    学习设计模式最好方式：
        在自己的做的工程中尽量思考使用
        
    设计原则：
        1、开闭原则[（Open Close Principle,简称OCP）]
            - 核心思想:软件体应该是对于扩展开放的，但是对于修改封闭的
                尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化
            - 理解:对于软件需求的多样，在设计时尽量的适应变化，提高项目的稳定性和灵活性
            - 应用: 当需求有改动，要修改代码了，此时您要做的是，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。
                当然，如果能够确保对整体架构不会产生任何影响，那么也没必要搞得那么复杂了，直接改这个类吧。
            
        2、里氏代换原则[(Liskov Substitution Principle, 简称LSP)]
            - 核心思想:程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换
            - 理解: 父类出现的地方子类都能出现
                - 增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行
            - 注意: 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，
                则建议断开父子继承关系 采用依赖、聚合、组合等关系代替继承
            - 应用: 在继承类时，务必重写（Override）父类中所有的方法，尤其需要注意父类的 protected 方法（它们往往是让您重写的），
                子类尽量不要暴露自己的 public 方法供外界调用。
                
        3、依赖倒置原则[（Dependence Inversion Principle,简称DIP）]
            - 核心思想: 认为一个方法应该遵从“依赖于抽象而不是一个实例”
                - 高层模块不应该依赖底层模块，二者都该依赖其抽象；(高层模块就是调用端，低层模块就是具体实现类)
                - 抽象不应该依赖细节；细节应该依赖抽象；(抽象就是指接口或抽象类。细节就是实现类)
            - 理解: 依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合
                依赖注入是该原则的一种实现方式
            - 应用: 并不是说，所有的类都要有一个对应的接口，而是说，如果有接口，那就尽量使用接口来编程吧
            
        4、接口隔离原则[（Interface Segregation Principle,简称ISP）]
            - 核心思想: 多个特定客户端接口要好于一个宽泛用途的接口(类间的依赖关系应该建立在最小的接口上)
            - 理解: 为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用
            - 应用: 当需要对外暴露接口时，需要再三斟酌，如果真的没有必要对外提供的，就删了吧。一旦您提供了，
                就意味着，您将来要多做一件事情，何苦要给自己找事做呢
            
        5、单一职责原则[（Single Responsibility Principle - SRP）]
            - 核心思想: 有且仅有一个原因引起类的变更
            - 理解: 假如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作
            - 应用: 当我们做系统设计时，如果发现有一个类拥有了两种的职责，那就问自己一个问题：
                可以将这个类分成两个类吗？如果真的有必要，那就分吧。千万不要让一个类干的事情太多！
            
        6、最少知识原则[迪米特法则（Law of Demeter,简称LoD）]
            - 核心思想:类间解耦
            - 一个类对自己依赖的类知道的越少越好。软件编程的总的原则：低耦合，高内聚。
            - 应用: 在做系统设计时，不要让一个类依赖于太多的其他类，需尽量减小依赖关系，否则，您死都不知道自己怎么死的。
    
{% endhighlight %}

# **设计模式分类**
## **创建型模式**
#### **1 单例模式**

#### **2 抽象工厂模式**

#### **3 建造者模式**

#### **4 工厂模式**

#### **5 原型模式**


## **结构型模式**
#### **6 适配器模式**

#### **7 桥接模式**

#### **8 装饰模式**

#### **9 组合模式**

#### **10 外观模式**

#### **11 享元模式**

#### **12 代理模式**



## **行为型模式**
#### **13 模板方法模式**

#### **14 命令模式**

#### **15 迭代器模式**

#### **16 观察者模式**

#### **17 中介者模式**

#### **18 备忘录模式**

#### **19 解释器模式**

#### **20 状态模式**

#### **21 策略模式**

#### **22 职责链模式(责任链模式)**

#### **23 访问者模式**











