---
layout: post
title:  "高并发"
date:   2018-11-29 23:14:00 +0800
tags: JUC
color: rgb(255,210,32)
cover: 'https://github.com/javasunCN/zhangzhBolg/blob/master/assets/img/spring/spring.jpg?raw=true'
subtitle: '高并发四板斧:缓存、熔断、限流和预热'
---


<center><b><h3>高并发四板斧:缓存、熔断、限流和预热</h3></b></center>

# 缓存

{% highlight text %}
    
{% endhighlight %} 

-----------------------

# 熔断

{% highlight text %}
    
{% endhighlight %} 

-----------------------

# 限流

{% highlight text %}
    
{% endhighlight %} 

-----------------------

# 预热

{% highlight text %}
    一、预热
        Warm Up，即冷启动/预热的方式。当系统长期处于低水位的情况下，流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。
        通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。
    二、预热故障现象
        1、DB重启后，瞬间死亡
            一个高并发环境下的DB，进程死亡后进行重启。由于业务处在高峰期间，上游的负载均衡策略发生了重分配。刚刚启动的DB瞬间接受了1/3的流量，然后load疯狂飙升，直至再无响应。           
            原因就是：新启动的DB，各种Cache并没有准备完毕，系统状态与正常运行时截然不同。可能平常1/10的量，就能够把它带入死亡。
        2、服务重启后，访问异常
            另外一个常见的问题是：我的一台服务器发生了问题，由于负载均衡的作用，剩下的机器立马承载了这些请求，运行的很好。当服务重新加入集群时，却发生了大量高耗时的请求，在请求量高的情况下，甚至大批大批的失败。
            
            引起的原因大概可以归结于：
            1、服务启动后，jvm并未完全准备完毕，JIT未编译等。
            2、应用程序使用的各种资源未准备就绪。
            3、负载均衡发生了rebalance。
            
    三、解决方式
        1、接口放量
            按照以上的分析，通过编码手段控制住所有的客户端调用，即可解决问题。
            
            一个简单的轮询方式
            
                1、我要能拿到所有要调用资源的集合，以及启动时间，冷启动的配置等。
                2、给这些资源分配一些权重，比如最大权重为100，配置100秒之后冷启动成功。假如现在是第15秒，则总权重就是100*(n-1)+15。
                3、根据算好的权重，进行分配，流量会根据时间流逝逐步增加，直到与其他节点等同。
                4、一个极端情况，我的后端只有1个实例，根本就启动不起来。
                
                拿SpringCloud来说，我们就要改变这些组件的行为。
                
                1、ribbon的负载均衡策略。
                2、网关的负载均衡策略。
                
                还好，它们都是基础组件，不用来回拷贝代码了。
        2、走马观花
            顾名思义，意思就是把所有的接口都提前访问一遍，让系统对资源进行提前准备。
            比如，遍历所有的http连接，然后发送请求。
            这种方法是部分有效的，一些懒加载的资源会在这个阶段陆续加载进来，但不是全部。
            JIT等一些增强功能，可能使得预热过程变得非常的长，走马观花的方式，只能在一定程度上有作用。
            
            再比如某些DB，在启动之后，会执行一些非常有特点的sql，使得PageCache里加载到最需要的热数据。
        3、状态保留
            系统在死亡时做一个快照，然后在启动时，原封不动的还原回来。
            
            这个过程就比较魔幻了，因为一般的非正常关闭，系统根本没有机会发表遗言，所以只能定时的，在运行中的系统中做快照。
            
            节点在启动时，再将快照加载到内存中。这在一些内存型的组件中应用广泛。
        4、摘除nginx->修改权重->reload nginx
{% endhighlight %} 

-----------------------



